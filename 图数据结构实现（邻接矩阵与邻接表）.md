# 图数据结构实现全解析

图是数据结构中用于描述多对多关系的核心结构，本文通过 C++ 实现了图的两种经典存储方式（邻接矩阵、邻接表）及全套操作，包括**文件输入驱动测试、可视化打印、完整生命周期管理**等功能，涵盖创建、边的增删、度计算、DFS/BFS 遍历、结构转换等，代码可直接复用，适合数据结构课程学习。

## 一、完整代码实现

```cpp
#include <iostream>
#include <queue>
#include <cstring>
#include <fstream>
using namespace std;

#define MAX_VERTEX_NUM 20   //最大顶点数
#define INFINITY 65535
//无穷大（用于有权图权值或无权图的“无连接”标记）

//图的类型枚举（有向图、有向网、无向图、无向网）
typedef enum { DG, DN, UDG, UDN } GraphKind;

//邻接矩阵的“边”单元
typedef struct ArcCell {
    int adj;// 无权图用0/1表示是否连接，有权图存储权值
    int* info;//弧/边的附加信息的指针(int类型可以改)
}ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];

//邻接矩阵表示的图
typedef struct MGraph {
    char vexs[MAX_VERTEX_NUM];  //顶点向量
    AdjMatrix arcs;             //邻接矩阵
    int vexnum;                 //当前顶点数
    int arcnum;                 //当前弧/边数
    GraphKind kind;             //图的类型标志
}MGraph;

//邻接表的“弧结点”
typedef struct ArcNode {
    int adjvex;                 //邻接顶点的位置下标
    struct ArcNode* nextarc;   //指向下一条弧的指针
    int* info;                 //弧的附加信息
} ArcNode;

//邻接表的“顶点结点”
typedef struct VNode {
    char data;                  //顶点信息
    ArcNode* firstarc;         //指向第一条依附该顶点的弧的指针
} VNode, AdjList[MAX_VERTEX_NUM];

//邻接表表示的图
typedef struct ALGraph {
    AdjList vertices;           //邻接表数组
    int vexnum;                 //当前顶点数
    int arcnum;                 //当前弧/边数
    GraphKind kind;             //图的类型标志
} ALGraph;

//定位顶点在邻接矩阵中的下标
int LocateVex(MGraph& G, char v) {
    for (int i = 0; i < G.vexnum; i++) {
        if (G.vexs[i] == v) return i;
    }
    return -1;//顶点不存在
}

//创建邻接矩阵图(以无向图为例，可删去一行变为有向图)
void CreateMGraph(MGraph& G, GraphKind kind) {
    cin >> G.vexnum >> G.arcnum;
    for (int i = 0; i < G.vexnum; i++) {
        cin >> G.vexs[i];
    }

    //初始化邻接矩阵
    for (int i = 0; i < G.vexnum; i++) {
        for (int j = 0; j < G.vexnum; j++) {
            G.arcs[i][j].adj = INFINITY;
            G.arcs[i][j].info = 0;
        }
    }
    char v1, v2;
    int i, j;
    for (int k = 0; k < G.arcnum; k++) {
        cin >> v1 >> v2;
        i = LocateVex(G, v1);
        j = LocateVex(G, v2);
        G.arcs[i][j].adj = 1;//"1"也可以是权值
        G.arcs[j][i].adj = 1;//若是有向图可以删除这一行
    }
}

//邻接矩阵→插入边
void InsertEdge_MGraph(MGraph& G, char v1, char v2) {
    int i = LocateVex(G, v1);
    int j = LocateVex(G, v2);
    if (i == -1 || j == -1) {
        return;
    }
    G.arcs[i][j].adj = 1;
    G.arcs[j][i].adj = 1;//若是有向图可以删除这一行
    G.arcnum++;
}

//邻接矩阵→删除边
void DeleteEdge_MGraph(MGraph& G, char v1, char v2) {
    int i = LocateVex(G, v1);
    int j = LocateVex(G, v2);
    if (i == -1 || j == -1) return;
    G.arcs[i][j].adj = 0;
    G.arcs[j][i].adj = 0;//若是有向图可以删除这一行
    G.arcnum--;
}


//邻接矩阵→出度（有向图）
int OutDegreeMGraph(MGraph& G, int v) {
    if (v < 0 || v >= G.vexnum) {
        return -1;
    }
    int degree = 0;
    for (int j = 0; j < G.vexnum; j++) {
        if (G.arcs[v][j].adj == 1) {
            degree++;
        }
    }
    return degree;
}

//邻接矩阵→入度（有向图）
int InDegreeMGraph(MGraph& G, int v) {
    if (v < 0 || v >= G.vexnum) {
        return -1;
    }
    int degree = 0;
    for (int i = 0; i < G.vexnum; i++) {
        if (G.arcs[i][v].adj == 1) {
            degree++;
        }
    }
    return degree;
}

//邻接矩阵→邻接表
void MGraphToALGraph(MGraph& G, ALGraph& AL) {
    AL.vexnum = G.vexnum;
    AL.arcnum = G.arcnum;
    AL.kind = G.kind;

    //初始化顶点表
    for (int i = 0; i < AL.vexnum; i++) {
        AL.vertices[i].data = G.vexs[i];
        AL.vertices[i].firstarc = NULL;
    }

    //建邻接表（链表）
    for (int i = 0; i < G.vexnum; i++) {
        for (int j = 0; j < G.vexnum; j++) {
            if (G.arcs[i][j].adj == 1) {
                ArcNode* p = new ArcNode;
                p->adjvex = j;
                p->info = G.arcs[i][j].info;
                p->nextarc = AL.vertices[i].firstarc;//头插法
                AL.vertices[i].firstarc = p;
            }
        }
    }
}

//邻接矩阵→DFS遍历(深度优先搜索)
void DFS_MGraph(MGraph& G, int v, bool visited[]) {
    cout << G.vexs[v] << " ";
    visited[v] = true;
    for (int j = 0; j < G.vexnum; j++) {
        if (G.arcs[v][j].adj == 1 && !visited[j]) {
            DFS_MGraph(G, j, visited);//对尚未访问的顶点调用DFS
        }
    }
}

//邻接矩阵→BFS遍历(广度优先搜索)
void BFS_MGraph(MGraph& G, int v, bool visited[]) {
    queue<int> q;
    q.push(v);
    visited[v] = true;
    cout << G.vexs[v] << " ";
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int j = 0; j < G.vexnum; j++) {
            if (G.arcs[u][j].adj == 1 && !visited[j]) {
                visited[j] = true;
                cout << G.vexs[j] << " ";
                q.push(j);
            }
        }
    }
}

//在邻接表中根据顶点数据找下标
int LocateVex_AL(ALGraph& AL, char v) {
    for (int i = 0; i < AL.vexnum; i++) {
        if (AL.vertices[i].data == v) {//遍历顶点数组匹配数据
            return i;//找到返回下标
        }
    }
    return -1;  //未找到返回-1
}

//创建邻接表（不调用插入边函数，内部直接实现边插入）
void CreateALGraph(ALGraph& AL, GraphKind kind) {
    AL.kind = kind;
    cin >> AL.vexnum >> AL.arcnum;
    for (int i = 0; i < AL.vexnum; i++) {
        cin >> AL.vertices[i].data; //初始化顶点数据
        AL.vertices[i].firstarc = NULL; //初始没有弧
    }

    //输入边信息并直接构建邻接表
    char v1, v2;
    int i, j;
    for (int k = 0; k < AL.arcnum; k++) {
        cin >> v1 >> v2;
        // 1. 定位两个顶点的下标
        i = LocateVex_AL(AL, v1);
        j = LocateVex_AL(AL, v2);
        if (i == -1 || j == -1) {
            cout << "顶点不存在，跳过该边！" << endl;
            continue;
        }

        //2.插入 v1→v2 的弧（头插法）
        ArcNode* p = new ArcNode;
        p->adjvex = j;
        p->info = 0; //附加信息初始化为0（可根据需求修改）
        p->nextarc = AL.vertices[i].firstarc;
        AL.vertices[i].firstarc = p;

        //3.无向图还需插入 v2→v1 的反向弧
        if (AL.kind == UDG || AL.kind == UDN) {
            ArcNode* q = new ArcNode;
            q->adjvex = i;
            q->info = 0;
            q->nextarc = AL.vertices[j].firstarc;
            AL.vertices[j].firstarc = q;
        }
    }
}

//邻接表→邻接矩阵
void ALGraphToMGraph(ALGraph& AL, MGraph& MG) {
    MG.vexnum = AL.vexnum;
    MG.arcnum = AL.arcnum;
    MG.kind = AL.kind;

    //复制顶点信息
    for (int i = 0; i < MG.vexnum; i++) {
        MG.vexs[i] = AL.vertices[i].data;
    }

    //初始化邻接矩阵
    for (int i = 0; i < MG.vexnum; i++) {
        for (int j = 0; j < MG.vexnum; j++) {
            MG.arcs[i][j].adj = INFINITY;
            MG.arcs[i][j].info = 0;
        }
    }

    //遍历邻接表填充矩阵
    for (int i = 0; i < AL.vexnum; i++) {
        ArcNode* p = AL.vertices[i].firstarc;
        while (p) {
            MG.arcs[i][p->adjvex].adj = 1;
            MG.arcs[p->adjvex][i].adj = 1;//若是有向图可以删除这一行
            p = p->nextarc;
        }
    }
}

// 邻接表→插入边
void InsertEdge_ALGraph(ALGraph& AL, char v1, char v2) {
    int i = LocateVex_AL(AL, v1);
    int j = LocateVex_AL(AL, v2);
    if (i == -1 || j == -1) return;

    ArcNode* p = new ArcNode;
    p->adjvex = j;
    p->info = 0;
    p->nextarc = AL.vertices[i].firstarc;
    AL.vertices[i].firstarc = p;

    if (AL.kind == UDG || AL.kind == UDN) {
        ArcNode* q = new ArcNode;
        q->adjvex = i;
        q->info = 0;
        q->nextarc = AL.vertices[j].firstarc;
        AL.vertices[j].firstarc = q;
    }
    AL.arcnum++;
}

//邻接表→删除边
void DeleteEdge_ALGraph(ALGraph& AL, char v1, char v2) {
    int i = LocateVex_AL(AL, v1);
    int j = LocateVex_AL(AL, v2);
    if (i == -1 || j == -1) return;

    //删除i→j的弧
    ArcNode* p = AL.vertices[i].firstarc;
    ArcNode* prev = NULL;
    while (p && p->adjvex != j) {
        prev = p;
        p = p->nextarc;
    }
    if (p) {
        if (prev) prev->nextarc = p->nextarc;
        else AL.vertices[i].firstarc = p->nextarc;
        delete p;
    }

    //无向图还要删除反向弧
    if (AL.kind == UDG || AL.kind == UDN) {
        p = AL.vertices[j].firstarc;
        prev = NULL;
        while (p && p->adjvex != i) {
            prev = p;
            p = p->nextarc;
        }
        if (p) {
            if (prev) prev->nextarc = p->nextarc;
            else AL.vertices[j].firstarc = p->nextarc;
            delete p;
        }
    }
    AL.arcnum--;
}

//邻接表→出度
int OutDegree_ALGraph(ALGraph& AL, int v) {
    if (v < 0 || v >= AL.vexnum) {
        return -1;
    }
    int degree = 0;
    ArcNode* p = AL.vertices[v].firstarc;
    while (p) {
        degree++;
        p = p->nextarc;
    }
    return degree;
}

//邻接表→入度(要遍历所有点，非常复杂，可以转化为逆邻接表)
int InDegree_ALGraph(ALGraph& AL, int v) {
    if (v < 0 || v >= AL.vexnum) return -1;
    int degree = 0;
    for (int i = 0; i < AL.vexnum; i++) {
        ArcNode* p = AL.vertices[i].firstarc;
        while (p) {
            if (p->adjvex == v) degree++;
            p = p->nextarc;
        }
    }
    return degree;
}

//邻接表→逆邻接表（有向图，存储“入边”）
void ALGraphToInverse(ALGraph& AL, ALGraph& inverseAL) {
    inverseAL.vexnum = AL.vexnum;
    inverseAL.arcnum = AL.arcnum;
    inverseAL.kind = AL.kind;

    //初始化顶点表
    for (int i = 0; i < inverseAL.vexnum; i++) {
        inverseAL.vertices[i].data = AL.vertices[i].data;
        inverseAL.vertices[i].firstarc = NULL;
    }

    //构建逆邻接表
    for (int i = 0; i < AL.vexnum; i++) {
        ArcNode* p = AL.vertices[i].firstarc;
        while (p) {
            ArcNode* q = new ArcNode;
            q->adjvex = i;
            q->info = p->info;
            q->nextarc = inverseAL.vertices[p->adjvex].firstarc;//头插法
            inverseAL.vertices[p->adjvex].firstarc = q;
            p = p->nextarc;
        }
    }
}

//根据逆邻接表计算入度（逆邻接表中v的邻接表长度即为入度）
//仅适用于有向图，无向图的逆邻接表与原表一致
int InDegree_InvALGraph(ALGraph& invAL, int v) {
    if (v < 0 || v >= invAL.vexnum) {//检查顶点索引合法性
        return -1;
    }
    int inDegree = 0;
    ArcNode* p = invAL.vertices[v].firstarc;//指向逆邻接表中v的第一个邻接节点
    while (p != NULL) {//遍历邻接表，统计节点数量
        inDegree++;
        p = p->nextarc;
    }
    return inDegree;
}

//邻接表→DFS遍历(深度优先搜索)
void DFS_ALGraph(ALGraph& AL, int v, bool visited[]) {
    cout << AL.vertices[v].data << " ";
    visited[v] = true;
    ArcNode* p = AL.vertices[v].firstarc;
    while (p) {
        if (!visited[p->adjvex]) {
            DFS_ALGraph(AL, p->adjvex, visited);
        }
        p = p->nextarc;
    }
}

//邻接表→BFS遍历(广度优先搜索)
void BFS_ALGraph(ALGraph& AL, int v, bool visited[]) {
    queue<int> q;
    q.push(v);
    visited[v] = true;
    cout << AL.vertices[v].data << " ";
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        ArcNode* p = AL.vertices[u].firstarc;
        while (p) {
            if (!visited[p->adjvex]) {
                visited[p->adjvex] = true;
                cout << AL.vertices[p->adjvex].data << " ";
                q.push(p->adjvex);
            }
            p = p->nextarc;
        }
    }
}

//邻接表销毁函数：释放所有动态分配的ArcNode节点，避免内存泄漏
void DestroyALGraph(ALGraph& AL) {
    //遍历每个顶点的邻接表
    for (int i = 0; i < AL.vexnum; i++) {
        ArcNode* current = AL.vertices[i].firstarc;//指向当前顶点的第一条弧
        while (current != NULL) {
            ArcNode* temp = current;//保存当前节点指针
            current = current->nextarc;//移动到下一条弧
            delete temp;//释放当前节点（用new分配的必须用delete释放）
            temp = NULL;//避免野指针
        }
        AL.vertices[i].firstarc = NULL; //清空顶点的弧指针
    }
}

//打印邻接矩阵
void PrintMGraph(MGraph& G) {
    //打印顶点表头
    cout << "  ";
    for (int i = 0; i < G.vexnum; i++) {
        cout << G.vexs[i] << " ";
    }
    cout << endl;

    //打印矩阵内容
    for (int i = 0; i < G.vexnum; i++) {
        cout << G.vexs[i] << " ";
        for (int j = 0; j < G.vexnum; j++) {
            if (G.arcs[i][j].adj == INFINITY) {
                cout << "∞ ";  // 用∞表示无连接
            }
            else {
                cout << G.arcs[i][j].adj << " ";
            }
        }
        cout << endl;
    }
}

//打印邻接表
void PrintALGraph(ALGraph& AL) {
    for (int i = 0; i < AL.vexnum; i++) {
        cout << AL.vertices[i].data << " -> ";
        ArcNode* p = AL.vertices[i].firstarc;
        while (p) {
            cout << AL.vertices[p->adjvex].data << " -> ";
            p = p->nextarc;
        }
        cout << "NULL" << endl;
    }
}

int main() {
    ifstream fin("input.txt");
    if (!fin.is_open()) {
        cerr << "无法打开输入文件！" << endl;
        return 1;
    }

    cin.rdbuf(fin.rdbuf());

    //------------------- 测试邻接矩阵（无向图UDG） -------------------
    cout << "===== 测试邻接矩阵（无向图） =====" << endl;
    GraphKind mg_kind;
    string kind_str;
    fin >> kind_str;  // 从文件读取图类型
    mg_kind = (kind_str == "UDG") ? UDG : DG;  //默认UDG

    MGraph MG;
    CreateMGraph(MG, mg_kind);  // 修正：去掉多余的fin参数
    cout << "\n创建后的邻接矩阵：\n";
    PrintMGraph(MG);

    //插入边
    char v1, v2;
    fin >> v1 >> v2;  // 从文件读取顶点
    cout << "\n插入边 " << v1 << "-" << v2 << " 后：\n";
    InsertEdge_MGraph(MG, v1, v2);
    PrintMGraph(MG);

    //删除边
    fin >> v1 >> v2;  // 从文件读取顶点
    cout << "\n删除边 " << v1 << "-" << v2 << " 后：\n";
    DeleteEdge_MGraph(MG, v1, v2);
    PrintMGraph(MG);

    //DFS和BFS遍历
    bool visited[MAX_VERTEX_NUM] = { false };
    cout << "\n邻接矩阵DFS遍历：";
    for (int i = 0; i < MG.vexnum; i++) {
        if (!visited[i]) DFS_MGraph(MG, i, visited);
    }

    memset(visited, 0, sizeof(visited));
    cout << "\n邻接矩阵BFS遍历：";
    for (int i = 0; i < MG.vexnum; i++) {
        if (!visited[i]) BFS_MGraph(MG, i, visited);
    }

    //出入度
    cout << "\n\n各顶点度数：\n";
    for (int i = 0; i < MG.vexnum; i++) {
        cout << MG.vexs[i] << "：出度=" << OutDegreeMGraph(MG, i)
            << "，入度=" << InDegreeMGraph(MG, i) << endl;
    }

    //------------------- 邻接矩阵转邻接表 -------------------
    cout << "\n===== 邻接矩阵转邻接表 =====" << endl;
    ALGraph AL_from_MG;
    MGraphToALGraph(MG, AL_from_MG);
    cout << "转换后的邻接表：\n";
    PrintALGraph(AL_from_MG);

    //转换后邻接表的遍历
    memset(visited, 0, sizeof(visited));
    cout << "\n转换后邻接表DFS：";
    for (int i = 0; i < AL_from_MG.vexnum; i++) {
        if (!visited[i]) DFS_ALGraph(AL_from_MG, i, visited);
    }

    memset(visited, 0, sizeof(visited));
    cout << "\n转换后邻接表BFS：";
    for (int i = 0; i < AL_from_MG.vexnum; i++) {
        if (!visited[i]) BFS_ALGraph(AL_from_MG, i, visited);
    }

    //------------------- 测试邻接表（有向图DG） -------------------
    cout << "\n\n===== 测试邻接表（有向图） =====" << endl;
    fin >> kind_str;  // 从文件读取图类型
    GraphKind al_kind = (kind_str == "DG") ? DG : UDG;  //默认DG

    ALGraph AL;
    CreateALGraph(AL, al_kind);  // 修正：去掉多余的fin参数
    cout << "\n创建后的邻接表：\n";
    PrintALGraph(AL);

    //插入边
    fin >> v1 >> v2;  // 从文件读取顶点
    cout << "\n插入边 " << v1 << "->" << v2 << " 后：\n";
    InsertEdge_ALGraph(AL, v1, v2);
    PrintALGraph(AL);

    //删除边
    fin >> v1 >> v2;  // 从文件读取顶点
    cout << "\n删除边 " << v1 << "->" << v2 << " 后：\n";
    DeleteEdge_ALGraph(AL, v1, v2);
    PrintALGraph(AL);

    //遍历
    memset(visited, 0, sizeof(visited));
    cout << "\n邻接表DFS：";
    for (int i = 0; i < AL.vexnum; i++) {
        if (!visited[i]) DFS_ALGraph(AL, i, visited);
    }

    memset(visited, 0, sizeof(visited));
    cout << "\n邻接表BFS：";
    for (int i = 0; i < AL.vexnum; i++) {
        if (!visited[i]) BFS_ALGraph(AL, i, visited);
    }

    //出入度
    cout << "\n\n各顶点度数：\n";
    for (int i = 0; i < AL.vexnum; i++) {
        cout << AL.vertices[i].data << "：出度=" << OutDegree_ALGraph(AL, i)
            << "，入度=" << InDegree_ALGraph(AL, i) << endl;
    }

    //------------------- 逆邻接表测试 -------------------
    cout << "\n===== 逆邻接表测试 =====" << endl;
    ALGraph invAL;
    ALGraphToInverse(AL, invAL);
    cout << "逆邻接表：\n";
    PrintALGraph(invAL);

    cout << "\n逆邻接表计算入度：\n";
    for (int i = 0; i < invAL.vexnum; i++) {
        cout << invAL.vertices[i].data << "：入度=" << InDegree_InvALGraph(invAL, i) << endl;
    }

    //------------------- 邻接表转邻接矩阵 -------------------
    cout << "\n===== 邻接表转邻接矩阵 =====" << endl;
    MGraph MG_from_AL;
    ALGraphToMGraph(AL, MG_from_AL);
    cout << "转换后的邻接矩阵：\n";
    PrintMGraph(MG_from_AL);

    //销毁邻接表
    DestroyALGraph(AL);
    DestroyALGraph(AL_from_MG);
    DestroyALGraph(invAL);
    cout << "\n所有邻接表已销毁，程序结束。" << endl;

    fin.close();
    return 0;
}
```

## 二、代码模块拆分解释（含对应代码）

### 1. 定位顶点函数（查找顶点在图中的下标）

#### （1）`LocateVex(MGraph& G, char v)`

**对应代码**：

```cpp
//定位顶点在邻接矩阵中的下标
int LocateVex(MGraph& G, char v) {
    for (int i = 0; i < G.vexnum; i++) {
        if (G.vexs[i] == v) return i;
    }
    return -1;//顶点不存在
}
```

**分析**：

- **功能**：在邻接矩阵的顶点数组`G.vexs`中，根据顶点字符`v`查找其下标（0 开始）。
- **参数**：`MGraph& G`（邻接矩阵对象）、`char v`（待查找顶点）。
- **逻辑**：遍历`G.vexs`数组，逐个匹配字符`v`，返回第一个匹配项的下标；未找到返回 - 1。
- **注意**：假设顶点字符唯一，若存在重复顶点，仅返回首个匹配项的下标。

#### （2）`LocateVex_AL(ALGraph& AL, char v)`

**对应代码**：

```cpp
//在邻接表中根据顶点数据找下标
int LocateVex_AL(ALGraph& AL, char v) {
    for (int i = 0; i < AL.vexnum; i++) {
        if (AL.vertices[i].data == v) {//遍历顶点数组匹配数据
            return i;//找到返回下标
        }
    }
    return -1;  //未找到返回-1
}
```

**分析**：

- **功能**：在邻接表的顶点数组`AL.vertices`中，根据顶点字符`v`查找其下标。
- **参数**：`ALGraph& AL`（邻接表对象）、`char v`（待查找顶点）。
- **逻辑**：遍历`AL.vertices`数组，匹配每个顶点的`data`字段与`v`，返回首个匹配项的下标；未找到返回 - 1。
- **与`LocateVex`的差异**：操作对象不同（邻接表的`vertices`数组 vs 邻接矩阵的`vexs`数组），但核心逻辑一致（线性遍历匹配）。

### 2. 创建图函数（初始化图的顶点和边）

#### （1）`CreateMGraph(MGraph& G, GraphKind kind)`

**对应代码**：

```cpp
//创建邻接矩阵图(以无向图为例，可删去一行变为有向图)
void CreateMGraph(MGraph& G, GraphKind kind) {
    cin >> G.vexnum >> G.arcnum;
    for (int i = 0; i < G.vexnum; i++) {
        cin >> G.vexs[i];
    }

    //初始化邻接矩阵
    for (int i = 0; i < G.vexnum; i++) {
        for (int j = 0; j < G.vexnum; j++) {
            G.arcs[i][j].adj = INFINITY;
            G.arcs[i][j].info = 0;
        }
    }
    char v1, v2;
    int i, j;
    for (int k = 0; k < G.arcnum; k++) {
        cin >> v1 >> v2;
        i = LocateVex(G, v1);
        j = LocateVex(G, v2);
        G.arcs[i][j].adj = 1;//"1"也可以是权值
        G.arcs[j][i].adj = 1;//若是有向图可以删除这一行
    }
}
```

**分析**：

- **功能**：初始化邻接矩阵图，包括顶点数据和边的连接关系。
- **参数**：`MGraph& G`（待初始化的邻接矩阵）、`GraphKind kind`（图类型，如无向图 UDG）。
- 逻辑：
  1. 读取顶点数`vexnum`、边数`arcnum`，以及顶点字符（存入`G.vexs`）；
  2. 初始化邻接矩阵：所有`adj`设为`INFINITY`（无连接），`info`设为 0；
  3. 读取每条边的两个顶点`v1, v2`，通过`LocateVex`找到下标`i, j`，标记`G.arcs[i][j].adj = 1`（有连接）；若为无向图，同步标记`G.arcs[j][i].adj = 1`（双向连接）。
- **注意**：有向图需删除`G.arcs[j][i].adj = 1`；若为网图，`1`可替换为具体权值。

#### （2）`CreateALGraph(ALGraph& AL, GraphKind kind)`

**对应代码**：

```cpp
//创建邻接表（不调用插入边函数，内部直接实现边插入）
void CreateALGraph(ALGraph& AL, GraphKind kind) {
    AL.kind = kind;
    cin >> AL.vexnum >> AL.arcnum;
    for (int i = 0; i < AL.vexnum; i++) {
        cin >> AL.vertices[i].data; //初始化顶点数据
        AL.vertices[i].firstarc = NULL; //初始没有弧
    }

    //输入边信息并直接构建邻接表
    char v1, v2;
    int i, j;
    for (int k = 0; k < AL.arcnum; k++) {
        cin >> v1 >> v2;
        // 1. 定位两个顶点的下标
        i = LocateVex_AL(AL, v1);
        j = LocateVex_AL(AL, v2);
        if (i == -1 || j == -1) {
            cout << "顶点不存在，跳过该边！" << endl;
            continue;
        }

        //2.插入 v1→v2 的弧（头插法）
        ArcNode* p = new ArcNode;
        p->adjvex = j;
        p->info = 0; //附加信息初始化为0（可根据需求修改）
        p->nextarc = AL.vertices[i].firstarc;
        AL.vertices[i].firstarc = p;

        //3.无向图还需插入 v2→v1 的反向弧
        if (AL.kind == UDG || AL.kind == UDN) {
            ArcNode* q = new ArcNode;
            q->adjvex = i;
            q->info = 0;
            q->nextarc = AL.vertices[j].firstarc;
            AL.vertices[j].firstarc = q;
        }
    }
}
```

**分析**：

- **功能**：初始化邻接表图，包括顶点数据和边的邻接关系（用链表存储）。
- **参数**：`ALGraph& AL`（待初始化的邻接表）、`GraphKind kind`（图类型）。
- 逻辑：
  1. 读取顶点数`vexnum`、边数`arcnum`，顶点字符存入`AL.vertices[i].data`，并初始化`firstarc`为`NULL`（无邻接弧）；
  2. 读取每条边的`v1, v2`，定位下标`i, j`；
  3. 用**头插法**创建弧节点`p`（存储`j`），插入`AL.vertices[i].firstarc`（`v1`的邻接链头部）；
  4. 若为无向图，创建反向弧节点`q`（存储`i`），插入`AL.vertices[j].firstarc`（`v2`的邻接链头部）。
- **优势**：头插法插入效率高（O (1)），无需遍历链表；无向图通过双向弧实现对称连接。

### 3. 边操作函数（插入 / 删除图中的边）

#### （1）`InsertEdge_MGraph(MGraph& G, char v1, char v2)`

**对应代码**：

```cpp
//邻接矩阵→插入边
void InsertEdge_MGraph(MGraph& G, char v1, char v2) {
    int i = LocateVex(G, v1);
    int j = LocateVex(G, v2);
    if (i == -1 || j == -1) {
        return;
    }
    G.arcs[i][j].adj = 1;
    G.arcs[j][i].adj = 1;//若是有向图可以删除这一行
    G.arcnum++;
}
```

**分析**：

- **功能**：向邻接矩阵图中插入一条边（`v1, v2`）。
- **参数**：`MGraph& G`（邻接矩阵）、`char v1, v2`（边的两个顶点）。
- 逻辑：
  1. 定位`v1, v2`的下标`i, j`；
  2. 若顶点不存在（`i=-1`或`j=-1`），直接返回；
  3. 标记边存在：`G.arcs[i][j].adj = 1`；无向图需同步标记`G.arcs[j][i].adj = 1`；
  4. 边数`G.arcnum`加 1。
- **注意**：未检查边是否已存在，可能重复插入（需根据需求补充判断）。

#### （2）`DeleteEdge_MGraph(MGraph& G, char v1, char v2)`

**对应代码**：

```cpp
//邻接矩阵→删除边
void DeleteEdge_MGraph(MGraph& G, char v1, char v2) {
    int i = LocateVex(G, v1);
    int j = LocateVex(G, v2);
    if (i == -1 || j == -1) return;
    G.arcs[i][j].adj = 0;
    G.arcs[j][i].adj = 0;//若是有向图可以删除这一行
    G.arcnum--;
}
```

**分析**：

- **功能**：从邻接矩阵图中删除一条边（`v1, v2`）。
- **参数**：同`InsertEdge_MGraph`。
- 逻辑：
  1. 定位`v1, v2`的下标`i, j`；
  2. 若顶点不存在，直接返回；
  3. 标记边不存在：`G.arcs[i][j].adj = 0`；无向图同步标记`G.arcs[j][i].adj = 0`；
  4. 边数`G.arcnum`减 1。

#### （3）`InsertEdge_ALGraph(ALGraph& AL, char v1, char v2)`

**对应代码**：

```cpp
// 邻接表→插入边
void InsertEdge_ALGraph(ALGraph& AL, char v1, char v2) {
    int i = LocateVex_AL(AL, v1);
    int j = LocateVex_AL(AL, v2);
    if (i == -1 || j == -1) return;

    ArcNode* p = new ArcNode;
    p->adjvex = j;
    p->info = 0;
    p->nextarc = AL.vertices[i].firstarc;
    AL.vertices[i].firstarc = p;

    if (AL.kind == UDG || AL.kind == UDN) {
        ArcNode* q = new ArcNode;
        q->adjvex = i;
        q->info = 0;
        q->nextarc = AL.vertices[j].firstarc;
        AL.vertices[j].firstarc = q;
    }
    AL.arcnum++;
}
```

**分析**：

- **功能**：向邻接表图中插入一条边（`v1, v2`）。
- **参数**：`ALGraph& AL`（邻接表）、`char v1, v2`（边的两个顶点）。
- 逻辑：
  1. 定位`v1, v2`的下标`i, j`；
  2. 若顶点不存在，直接返回；
  3. 头插法创建弧节点`p`（存储`j`），插入`AL.vertices[i].firstarc`（`v1`的邻接链）；
  4. 无向图需创建反向弧节点`q`（存储`i`），插入`AL.vertices[j].firstarc`（`v2`的邻接链）；
  5. 边数`AL.arcnum`加 1。

#### （4）`DeleteEdge_ALGraph(ALGraph& AL, char v1, char v2)`

**对应代码**：

```cpp
//邻接表→删除边
void DeleteEdge_ALGraph(ALGraph& AL, char v1, char v2) {
    int i = LocateVex_AL(AL, v1);
    int j = LocateVex_AL(AL, v2);
    if (i == -1 || j == -1) return;

    //删除i→j的弧
    ArcNode* p = AL.vertices[i].firstarc;
    ArcNode* prev = NULL;
    while (p && p->adjvex != j) {
        prev = p;
        p = p->nextarc;
    }
    if (p) {
        if (prev) prev->nextarc = p->nextarc;
        else AL.vertices[i].firstarc = p->nextarc;
        delete p;
    }

    //无向图还要删除反向弧
    if (AL.kind == UDG || AL.kind == UDN) {
        p = AL.vertices[j].firstarc;
        prev = NULL;
        while (p && p->adjvex != i) {
            prev = p;
            p = p->nextarc;
        }
        if (p) {
            if (prev) prev->nextarc = p->nextarc;
            else AL.vertices[j].firstarc = p->nextarc;
            delete p;
        }
    }
    AL.arcnum--;
}
```

**分析**：

- **功能**：从邻接表图中删除一条边（`v1, v2`）。
- **参数**：同`InsertEdge_ALGraph`。
- 逻辑：
  1. 定位`v1, v2`的下标`i, j`；
  2. 删除`v1→v2`的弧：遍历`AL.vertices[i].firstarc`，找到指向`j`的弧节点`p`，通过前驱指针`prev`调整链表（跳过`p`），释放`p`的内存；
  3. 无向图需重复步骤 2，删除`v2→v1`的反向弧；
  4. 边数`AL.arcnum`减 1。
- **难点**：链表节点删除需维护前驱指针，避免断链；必须释放动态内存（否则泄漏）。

### 4. 度数计算函数（统计顶点的入度 / 出度）

#### （1）`OutDegreeMGraph(MGraph& G, int v)`

**对应代码**：

```cpp
//邻接矩阵→出度（有向图）
int OutDegreeMGraph(MGraph& G, int v) {
    if (v < 0 || v >= G.vexnum) {
        return -1;
    }
    int degree = 0;
    for (int j = 0; j < G.vexnum; j++) {
        if (G.arcs[v][j].adj == 1) {
            degree++;
        }
    }
    return degree;
}
```

**分析**：

- **功能**：计算邻接矩阵中顶点`v`（下标）的出度（从`v`出发的边数）。
- **参数**：`MGraph& G`（邻接矩阵）、`int v`（顶点下标，需合法）。
- **逻辑**：遍历`v`对应的行（`G.arcs[v][j]`），统计`adj == 1`的数量（即出度）；`v`非法返回 - 1。

#### （2）`InDegreeMGraph(MGraph& G, int v)`

**对应代码**：

```cpp
//邻接矩阵→入度（有向图）
int InDegreeMGraph(MGraph& G, int v) {
    if (v < 0 || v >= G.vexnum) {
        return -1;
    }
    int degree = 0;
    for (int i = 0; i < G.vexnum; i++) {
        if (G.arcs[i][v].adj == 1) {
            degree++;
        }
    }
    return degree;
}
```

**分析**：

- **功能**：计算邻接矩阵中顶点`v`的入度（指向`v`的边数）。
- **参数**：同`OutDegreeMGraph`。
- **逻辑**：遍历`v`对应的列（`G.arcs[i][v]`），统计`adj == 1`的数量（即入度）；`v`非法返回 - 1。

#### （3）`OutDegree_ALGraph(ALGraph& AL, int v)`

**对应代码**：

```cpp
//邻接表→出度
int OutDegree_ALGraph(ALGraph& AL, int v) {
    if (v < 0 || v >= AL.vexnum) {
        return -1;
    }
    int degree = 0;
    ArcNode* p = AL.vertices[v].firstarc;
    while (p) {
        degree++;
        p = p->nextarc;
    }
    return degree;
}
```

**分析**：

- **功能**：计算邻接表中顶点`v`的出度。
- **参数**：`ALGraph& AL`（邻接表）、`int v`（顶点下标）。
- **逻辑**：遍历`v`的邻接链（`AL.vertices[v].firstarc`），统计链中节点数量（即出度）；`v`非法返回 - 1。
- **优势**：时间复杂度 O (1)（仅遍历自身邻接链），效率高于邻接矩阵的 O (n)。

#### （4）`InDegree_ALGraph(ALGraph& AL, int v)`

**对应代码**：

```cpp
//邻接表→入度(要遍历所有点，非常复杂，可以转化为逆邻接表)
int InDegree_ALGraph(ALGraph& AL, int v) {
    if (v < 0 || v >= AL.vexnum) return -1;
    int degree = 0;
    for (int i = 0; i < AL.vexnum; i++) {
        ArcNode* p = AL.vertices[i].firstarc;
        while (p) {
            if (p->adjvex == v) degree++;
            p = p->nextarc;
        }
    }
    return degree;
}
```

**分析**：

- **功能**：计算邻接表中顶点`v`的入度（低效方法）。
- **参数**：同`OutDegree_ALGraph`。
- **逻辑**：遍历所有顶点的邻接链，统计指向`v`的弧节点数量（即入度）；`v`非法返回 - 1。
- **缺点**：时间复杂度 O (n+e)（n 为顶点数，e 为边数），仅适合临时调试。

#### （5）`InDegree_InvALGraph(ALGraph& invAL, int v)`

**对应代码**：

```cpp
//根据逆邻接表计算入度（逆邻接表中v的邻接表长度即为入度）
//仅适用于有向图，无向图的逆邻接表与原表一致
int InDegree_InvALGraph(ALGraph& invAL, int v) {
    if (v < 0 || v >= invAL.vexnum) {//检查顶点索引合法性
        return -1;
    }
    int inDegree = 0;
    ArcNode* p = invAL.vertices[v].firstarc;//指向逆邻接表中v的第一个邻接节点
    while (p != NULL) {//遍历邻接表，统计节点数量
        inDegree++;
        p = p->nextarc;
    }
    return inDegree;
}
```

**分析**：

- **功能**：基于逆邻接表计算顶点`v`的入度（高效方法，仅适用于有向图）。
- **参数**：`ALGraph& invAL`（逆邻接表）、`int v`（顶点下标）。
- **逻辑**：逆邻接表中，`v`的邻接链存储所有指向`v`的边，因此链的长度即为入度；`v`非法返回 - 1。
- **优势**：时间复杂度 O (1)，解决了普通邻接表计算入度效率低的问题。

### 5. 结构转换函数（邻接矩阵↔邻接表，邻接表→逆邻接表）

#### （1）`MGraphToALGraph(MGraph& G, ALGraph& AL)`

**对应代码**：

```cpp
//邻接矩阵→邻接表
void MGraphToALGraph(MGraph& G, ALGraph& AL) {
    AL.vexnum = G.vexnum;
    AL.arcnum = G.arcnum;
    AL.kind = G.kind;

    //初始化顶点表
    for (int i = 0; i < AL.vexnum; i++) {
        AL.vertices[i].data = G.vexs[i];
        AL.vertices[i].firstarc = NULL;
    }

    //建邻接表（链表）
    for (int i = 0; i < G.vexnum; i++) {
        for (int j = 0; j < G.vexnum; j++) {
            if (G.arcs[i][j].adj == 1) {
                ArcNode* p = new ArcNode;
                p->adjvex = j;
                p->info = G.arcs[i][j].info;
                p->nextarc = AL.vertices[i].firstarc;//头插法
                AL.vertices[i].firstarc = p;
            }
        }
    }
}
```

**分析**：

- **功能**：将邻接矩阵图转换为邻接表图。
- **参数**：`MGraph& G`（源邻接矩阵）、`ALGraph& AL`（目标邻接表）。
- 逻辑：
  1. 复制元数据：顶点数、边数、图类型从`G`到`AL`；
  2. 初始化顶点表：`AL.vertices[i].data`复制`G.vexs[i]`，`firstarc`设为`NULL`；
  3. 构建邻接链：遍历`G.arcs`，对`G.arcs[i][j].adj == 1`的边，用头插法创建弧节点`p`（存储`j`），插入`AL.vertices[i].firstarc`。

#### （2）`ALGraphToMGraph(ALGraph& AL, MGraph& MG)`

**对应代码**：

```cpp
//邻接表→邻接矩阵
void ALGraphToMGraph(ALGraph& AL, MGraph& MG) {
    MG.vexnum = AL.vexnum;
    MG.arcnum = AL.arcnum;
    MG.kind = AL.kind;

    //复制顶点信息
    for (int i = 0; i < MG.vexnum; i++) {
        MG.vexs[i] = AL.vertices[i].data;
    }

    //初始化邻接矩阵
    for (int i = 0; i < MG.vexnum; i++) {
        for (int j = 0; j < MG.vexnum; j++) {
            MG.arcs[i][j].adj = INFINITY;
            MG.arcs[i][j].info = 0;
        }
    }

    //遍历邻接表填充矩阵
    for (int i = 0; i < AL.vexnum; i++) {
        ArcNode* p = AL.vertices[i].firstarc;
        while (p) {
            MG.arcs[i][p->adjvex].adj = 1;
            MG.arcs[p->adjvex][i].adj = 1;//若是有向图可以删除这一行
            p = p->nextarc;
        }
    }
}
```

**分析**：

- **功能**：将邻接表图转换为邻接矩阵图。
- **参数**：`ALGraph& AL`（源邻接表）、`MGraph& MG`（目标邻接矩阵）。
- 逻辑：
  1. 复制元数据：顶点数、边数、图类型从`AL`到`MG`；
  2. 初始化顶点表：`MG.vexs`复制`AL.vertices[i].data`；
  3. 初始化邻接矩阵：所有`adj`设为`INFINITY`；
  4. 填充矩阵：遍历每个顶点`i`的邻接链，对每条弧`i→j`，标记`MG.arcs[i][j].adj = 1`；无向图同步标记`MG.arcs[j][i].adj = 1`。

#### （3）`ALGraphToInverse(ALGraph& AL, ALGraph& inverseAL)`

**对应代码**：

```cpp
//邻接表→逆邻接表（有向图，存储“入边”）
void ALGraphToInverse(ALGraph& AL, ALGraph& inverseAL) {
    inverseAL.vexnum = AL.vexnum;
    inverseAL.arcnum = AL.arcnum;
    inverseAL.kind = AL.kind;

    //初始化顶点表
    for (int i = 0; i < inverseAL.vexnum; i++) {
        inverseAL.vertices[i].data = AL.vertices[i].data;
        inverseAL.vertices[i].firstarc = NULL;
    }

    //构建逆邻接表
    for (int i = 0; i < AL.vexnum; i++) {
        ArcNode* p = AL.vertices[i].firstarc;
        while (p) {
            ArcNode* q = new ArcNode;
            q->adjvex = i;
            q->info = p->info;
            q->nextarc = inverseAL.vertices[p->adjvex].firstarc;//头插法
            inverseAL.vertices[p->adjvex].firstarc = q;
            p = p->nextarc;
        }
    }
}
```

**分析**：

- **功能**：将有向图的邻接表转换为逆邻接表（存储 “入边” 信息）。
- **参数**：`ALGraph& AL`（源邻接表，存 “出边”）、`ALGraph& inverseAL`（目标逆邻接表，存 “入边”）。
- 逻辑：
  1. 复制元数据：顶点数、边数、图类型与`AL`一致；
  2. 初始化顶点表：`inverseAL.vertices[i].data`复制`AL`的顶点数据；
  3. 构建逆邻接链：对`AL`中每条弧`i→j`，创建逆弧`j→i`（头插法插入`inverseAL.vertices[j].firstarc`）。
- **作用**：将 “入边” 转换为逆邻接表的 “出边”，使入度计算效率从 O (n+e) 提升至 O (1)。

### 6. 遍历函数（深度优先 DFS / 广度优先 BFS）

#### （1）`DFS_MGraph(MGraph& G, int v, bool visited[])`

**对应代码**：

```cpp
//邻接矩阵→DFS遍历(深度优先搜索)
void DFS_MGraph(MGraph& G, int v, bool visited[]) {
    cout << G.vexs[v] << " ";
    visited[v] = true;
    for (int j = 0; j < G.vexnum; j++) {
        if (G.arcs[v][j].adj == 1 && !visited[j]) {
            DFS_MGraph(G, j, visited);//对尚未访问的顶点调用DFS
        }
    }
}
```

**分析**：

- **功能**：从顶点`v`出发，对邻接矩阵图进行深度优先搜索遍历。
- **参数**：`MGraph& G`（邻接矩阵）、`int v`（起始顶点下标）、`bool visited[]`（访问标记数组）。
- 逻辑（递归）：
  1. 访问`v`（输出数据），标记`visited[v] = true`；
  2. 遍历所有顶点`j`，若`G.arcs[v][j].adj == 1`且`j`未访问，递归遍历`j`。
- **特点**：优先深入探索邻接顶点，适合 “探路” 场景。

#### （2）`BFS_MGraph(MGraph& G, int v, bool visited[])`

**对应代码**：

```cpp
//邻接矩阵→BFS遍历(广度优先搜索)
void BFS_MGraph(MGraph& G, int v, bool visited[]) {
    queue<int> q;
    q.push(v);
    visited[v] = true;
    cout << G.vexs[v] << " ";
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int j = 0; j < G.vexnum; j++) {
            if (G.arcs[u][j].adj == 1 && !visited[j]) {
                visited[j] = true;
                cout << G.vexs[j] << " ";
                q.push(j);
            }
        }
    }
}
```

**分析**：

- **功能**：从顶点`v`出发，对邻接矩阵图进行广度优先搜索遍历。
- **参数**：同`DFS_MGraph`。
- 逻辑（队列）：
  1. 访问`v`，标记已访问，入队；
  2. 队列非空时，出队顶点`u`，遍历所有`j`，若`G.arcs[u][j].adj == 1`且`j`未访问，访问`j`并入队；
  3. 重复至队列为空。
- **特点**：按层次访问，适合 “最短路径” 场景（无权图中首次访问路径最短）。

#### （3）`DFS_ALGraph(ALGraph& AL, int v, bool visited[])`

**对应代码**：

```cpp
//邻接表→DFS遍历(深度优先搜索)
void DFS_ALGraph(ALGraph& AL, int v, bool visited[]) {
    cout << AL.vertices[v].data << " ";
    visited[v] = true;
    ArcNode* p = AL.vertices[v].firstarc;
    while (p) {
        if (!visited[p->adjvex]) {
            DFS_ALGraph(AL, p->adjvex, visited);
        }
        p = p->nextarc;
    }
}
```

**分析**：

- **功能**：从顶点`v`出发，对邻接表图进行深度优先搜索遍历。
- **参数**：`ALGraph& AL`（邻接表）、`int v`（起始顶点下标）、`bool visited[]`（访问标记）。
- 逻辑（递归）：
  1. 访问`v`，标记已访问；
  2. 遍历`v`的邻接链，对未访问的邻接顶点`p->adjvex`，递归遍历。
- **与`DFS_MGraph`的差异**：通过邻接链获取邻接顶点（而非遍历全量顶点），效率更高（尤其稀疏图）。

#### （4）`BFS_ALGraph(ALGraph& AL, int v, bool visited[])`

**对应代码**：

```cpp
//邻接表→BFS遍历(广度优先搜索)
void BFS_ALGraph(ALGraph& AL, int v, bool visited[]) {
    queue<int> q;
    q.push(v);
    visited[v] = true;
    cout << AL.vertices[v].data << " ";
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        ArcNode* p = AL.vertices[u].firstarc;
        while (p) {
            if (!visited[p->adjvex]) {
                visited[p->adjvex] = true;
                cout << AL.vertices[p->adjvex].data << " ";
                q.push(p->adjvex);
            }
            p = p->nextarc;
        }
    }
}
```

**分析**：

- **功能**：从顶点`v`出发，对邻接表图进行广度优先搜索遍历。
- **参数**：同`DFS_ALGraph`。
- 逻辑（队列）：
  1. 访问`v`，标记已访问，入队；
  2. 队列非空时，出队顶点`u`，遍历`u`的邻接链，对未访问的`p->adjvex`，访问并入队；
  3. 重复至队列为空。
- **与`BFS_MGraph`的差异**：通过邻接链获取邻接顶点，减少无效遍历（适合稀疏图）。

### 7. 销毁函数（释放动态内存）

#### `DestroyALGraph(ALGraph& AL)`

**对应代码**：

```cpp
//邻接表销毁函数：释放所有动态分配的ArcNode节点，避免内存泄漏
void DestroyALGraph(ALGraph& AL) {
    //遍历每个顶点的邻接表
    for (int i = 0; i < AL.vexnum; i++) {
        ArcNode* current = AL.vertices[i].firstarc;//指向当前顶点的第一条弧
        while (current != NULL) {
            ArcNode* temp = current;//保存当前节点指针
            current = current->nextarc;//移动到下一条弧
            delete temp;//释放当前节点（用new分配的必须用delete释放）
            temp = NULL;//避免野指针
        }
        AL.vertices[i].firstarc = NULL; //清空顶点的弧指针
    }
}
```

**分析**：

- **功能**：释放邻接表中所有动态分配的弧节点（`ArcNode`），避免内存泄漏。
- **参数**：`ALGraph& AL`（待销毁的邻接表）。
- 逻辑：
  1. 遍历每个顶点`i`；
  2. 对`i`的邻接链，用`current`指针遍历所有弧节点：`temp`保存当前节点，`current`移至下一个，释放`temp`；
  3. 清空`AL.vertices[i].firstarc`（避免野指针）。
- **必要性**：弧节点通过`new`分配，若不释放会导致内存泄漏（尤其长期运行的程序）。

### 8. 打印函数（可视化图结构）

#### （1）`PrintMGraph(MGraph& G)`

**对应代码**：

```cpp
//打印邻接矩阵
void PrintMGraph(MGraph& G) {
    //打印顶点表头
    cout << "  ";
    for (int i = 0; i < G.vexnum; i++) {
        cout << G.vexs[i] << " ";
    }
    cout << endl;

    //打印矩阵内容
    for (int i = 0; i < G.vexnum; i++) {
        cout << G.vexs[i] << " ";
        for (int j = 0; j < G.vexnum; j++) {
            if (G.arcs[i][j].adj == INFINITY) {
                cout << "∞ ";  // 用∞表示无连接
            }
            else {
                cout << G.arcs[i][j].adj << " ";
            }
        }
        cout << endl;
    }
}
```

**分析**：

- **功能**：以表格形式打印邻接矩阵，直观展示顶点连接关系。
- **参数**：`MGraph& G`（邻接矩阵）。
- 输出格式：
  - 第一行为顶点表头（横向展示所有顶点）；
  - 每行对应一个顶点，横向展示与其他顶点的连接（`1`为连接，`∞`为无连接）。

#### （2）`PrintALGraph(ALGraph& AL)`

**对应代码**：

```cpp
//打印邻接表
void PrintALGraph(ALGraph& AL) {
    for (int i = 0; i < AL.vexnum; i++) {
        cout << AL.vertices[i].data << " -> ";
        ArcNode* p = AL.vertices[i].firstarc;
        while (p) {
            cout << AL.vertices[p->adjvex].data << " -> ";
            p = p->nextarc;
        }
        cout << "NULL" << endl;
    }
}
```

**分析**：

- **功能**：以 “顶点→邻接顶点→...→NULL” 形式打印邻接表，展示每个顶点的邻接关系。
- **参数**：`ALGraph& AL`（邻接表）。
- **输出格式**：每个顶点一行，依次打印其邻接链中的顶点，最后以`NULL`结束。

### 9. `main`函数（测试入口）

**对应代码**：

```cpp
int main() {
    ifstream fin("input.txt");
    if (!fin.is_open()) {
        cerr << "无法打开输入文件！" << endl;
        return 1;
    }

    cin.rdbuf(fin.rdbuf());

    //------------------- 测试邻接矩阵（无向图UDG） -------------------
    cout << "===== 测试邻接矩阵（无向图） =====" << endl;
    GraphKind mg_kind;
    string kind_str;
    fin >> kind_str;  // 从文件读取图类型
    mg_kind = (kind_str == "UDG") ? UDG : DG;  //默认UDG

    MGraph MG;
    CreateMGraph(MG, mg_kind);  // 创建邻接矩阵
    cout << "\n创建后的邻接矩阵：\n";
    PrintMGraph(MG);

    //插入边
    char v1, v2;
    fin >> v1 >> v2;  // 从文件读取顶点
    cout << "\n插入边 " << v1 << "-" << v2 << " 后：\n";
    InsertEdge_MGraph(MG, v1, v2);
    PrintMGraph(MG);

    //删除边
    fin >> v1 >> v2;  // 从文件读取顶点
    cout << "\n删除边 " << v1 << "-" << v2 << " 后：\n";
    DeleteEdge_MGraph(MG, v1, v2);
    PrintMGraph(MG);

    //DFS和BFS遍历
    bool visited[MAX_VERTEX_NUM] = { false };
    cout << "\n邻接矩阵DFS遍历：";
    for (int i = 0; i < MG.vexnum; i++) {
        if (!visited[i]) DFS_MGraph(MG, i, visited);
    }

    memset(visited, 0, sizeof(visited));
    cout << "\n邻接矩阵BFS遍历：";
    for (int i = 0; i < MG.vexnum; i++) {
        if (!visited[i]) BFS_MGraph(MG, i, visited);
    }

    //出入度
    cout << "\n\n各顶点度数：\n";
    for (int i = 0; i < MG.vexnum; i++) {
        cout << MG.vexs[i] << "：出度=" << OutDegreeMGraph(MG, i)
            << "，入度=" << InDegreeMGraph(MG, i) << endl;
    }

    //------------------- 邻接矩阵转邻接表 -------------------
    cout << "\n===== 邻接矩阵转邻接表 =====" << endl;
    ALGraph AL_from_MG;
    MGraphToALGraph(MG, AL_from_MG);
    cout << "转换后的邻接表：\n";
    PrintALGraph(AL_from_MG);

    //转换后邻接表的遍历
    memset(visited, 0, sizeof(visited));
    cout << "\n转换后邻接表DFS：";
    for (int i = 0; i < AL_from_MG.vexnum; i++) {
        if (!visited[i]) DFS_ALGraph(AL_from_MG, i, visited);
    }

    memset(visited, 0, sizeof(visited));
    cout << "\n转换后邻接表BFS：";
    for (int i = 0; i < AL_from_MG.vexnum; i++) {
        if (!visited[i]) BFS_ALGraph(AL_from_MG, i, visited);
    }

    //------------------- 测试邻接表（有向图DG） -------------------
    cout << "\n\n===== 测试邻接表（有向图） =====" << endl;
    fin >> kind_str;  // 从文件读取图类型
    GraphKind al_kind = (kind_str == "DG") ? DG : UDG;  //默认DG

    ALGraph AL;
    CreateALGraph(AL, al_kind);  // 创建邻接表
    cout << "\n创建后的邻接表：\n";
    PrintALGraph(AL);

    //插入边
    fin >> v1 >> v2;  // 从文件读取顶点
    cout << "\n插入边 " << v1 << "->" << v2 << " 后：\n";
    InsertEdge_ALGraph(AL, v1, v2);
    PrintALGraph(AL);

    //删除边
    fin >> v1 >> v2;  // 从文件读取顶点
    cout << "\n删除边 " << v1 << "->" << v2 << " 后：\n";
    DeleteEdge_ALGraph(AL, v1, v2);
    PrintALGraph(AL);

    //遍历
    memset(visited, 0, sizeof(visited));
    cout << "\n邻接表DFS：";
    for (int i = 0; i < AL.vexnum; i++) {
        if (!visited[i]) DFS_ALGraph(AL, i, visited);
    }

    memset(visited, 0, sizeof(visited));
    cout << "\n邻接表BFS：";
    for (int i = 0; i < AL.vexnum; i++) {
        if (!visited[i]) BFS_ALGraph(AL, i, visited);
    }

    //出入度
    cout << "\n\n各顶点度数：\n";
    for (int i = 0; i < AL.vexnum; i++) {
        cout << AL.vertices[i].data << "：出度=" << OutDegree_ALGraph(AL, i)
            << "，入度=" << InDegree_ALGraph(AL, i) << endl;
    }

    //------------------- 逆邻接表测试 -------------------
    cout << "\n===== 逆邻接表测试 =====" << endl;
    ALGraph invAL;
    ALGraphToInverse(AL, invAL);
    cout << "逆邻接表：\n";
    PrintALGraph(invAL);

    cout << "\n逆邻接表计算入度：\n";
    for (int i = 0; i < invAL.vexnum; i++) {
        cout << invAL.vertices[i].data << "：入度=" << InDegree_InvALGraph(invAL, i) << endl;
    }

    //------------------- 邻接表转邻接矩阵 -------------------
    cout << "\n===== 邻接表转邻接矩阵 =====" << endl;
    MGraph MG_from_AL;
    ALGraphToMGraph(AL, MG_from_AL);
    cout << "转换后的邻接矩阵：\n";
    PrintMGraph(MG_from_AL);

    //销毁邻接表
    DestroyALGraph(AL);
    DestroyALGraph(AL_from_MG);
    DestroyALGraph(invAL);
    cout << "\n所有邻接表已销毁，程序结束。" << endl;

    fin.close();
    return 0;
}
```

**分析**：

- **功能**：作为程序入口，测试图的所有功能（创建、边操作、遍历、转换等）。
- 核心流程：
  1. 配置文件输入：打开`input.txt`，重定向`cin`到文件（自动化测试）；
  2. 邻接矩阵（无向图）测试：创建→插入边→删除边→DFS/BFS→度数→转邻接表；
  3. 邻接表（有向图）测试：创建→插入边→删除边→DFS/BFS→度数→转逆邻接表→逆表入度；
  4. 转换验证：邻接表转邻接矩阵（验证正确性）；
  5. 内存管理：销毁所有邻接表的动态内存；
  6. 关闭文件，程序结束。
- **作用**：串联所有模块，验证代码正确性，输出测试结果。