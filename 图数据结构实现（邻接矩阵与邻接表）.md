## 图数据结构实现全解析

图是数据结构中用于描述多对多关系的核心结构，本文通过 C++ 实现了图的两种经典存储方式（邻接矩阵、邻接表）及全套操作，包括创建、边的增删、度计算、DFS/BFS 遍历、结构转换等，代码可直接复用。

### 一、完整代码实现

```cpp
#include <iostream>
#include <queue>
#include <cstring>
using namespace std;

#define MAX_VERTEX_NUM 20   //最大顶点数
#define INFINITY 65535     
//无穷大（用于有权图权值或无权图的“无连接”标记）

//图的类型枚举（有向图、有向网、无向图、无向网）
typedef enum { DG, DN, UDG, UDN } GraphKind;

//邻接矩阵的“边”单元
typedef struct ArcCell{
	int adj;// 无权图用0/1表示是否连接，有权图存储权值
	int * info;//弧/边的附加信息的指针(int类型可以改)
}ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];

//邻接矩阵表示的图
typedef struct MGraph {
    char vexs[MAX_VERTEX_NUM];  //顶点向量
    AdjMatrix arcs;             //邻接矩阵
    int vexnum;                 //当前顶点数
    int arcnum;                 //当前弧/边数
    GraphKind kind;             //图的类型标志
}MGraph;

//邻接表的“弧结点”
typedef struct ArcNode {
    int adjvex;                 //邻接顶点的位置下标
    struct ArcNode * nextarc;   //指向下一条弧的指针
    int * info;                 //弧的附加信息
} ArcNode;

//邻接表的“顶点结点”
typedef struct VNode {
    char data;                  //顶点信息
    ArcNode * firstarc;         //指向第一条依附该顶点的弧的指针
} VNode, AdjList[MAX_VERTEX_NUM];

//邻接表表示的图
typedef struct ALGraph{
    AdjList vertices;           //邻接表数组
    int vexnum;                 //当前顶点数
    int arcnum;                 //当前弧/边数
    GraphKind kind;             //图的类型标志
} ALGraph;

//定位顶点在邻接矩阵中的下标
int LocateVex(MGraph& G, char v) {
    for (int i = 0; i < G.vexnum; i++) {
        if (G.vexs[i] == v) return i;
    }
    return -1;//顶点不存在
}

//创建邻接矩阵图(以无向图为例，可删去一行变为有向图)
void CreateMGraph(MGraph& G, GraphKind kind) {
    cout << "输入顶点数和弧/边数：";
    cin >> G.vexnum >> G.arcnum;

    cout << "输入" << G.vexnum << "个顶点：" << endl;

    for (int i = 0; i < G.vexnum; i++) {
        cin >> G.vexs[i];
    }

    //初始化邻接矩阵
    for (int i = 0; i < G.vexnum; i++) {
        for (int j = 0; j < G.vexnum; j++) {
            G.arcs[i][j].adj = INFINITY;
            G.arcs[i][j].info = 0;
        }
    }

    //输入弧/边信息
    cout << "输入每条弧/边的两个顶点（如A B）：" << endl;
    char v1, v2;
    int i, j;
    for (int k = 0; k < G.arcnum; k++) {
        cin >> v1 >> v2;
        i = LocateVex(G, v1);
        j = LocateVex(G, v2);
        G.arcs[i][j].adj = 1;//"1"也可以是权值
        G.arcs[j][i].adj = 1;//若是有向图可以删除这一行
    }
}

//邻接矩阵→插入边
void InsertEdge_MGraph(MGraph& G, char v1, char v2) {
    int i = LocateVex(G, v1);
    int j = LocateVex(G, v2);
    if (i == -1 || j == -1) {
        return;
    }
    G.arcs[i][j].adj = 1;
    G.arcs[j][i].adj = 1;//若是有向图可以删除这一行
    G.arcnum++;
}

//邻接矩阵→删除边
void DeleteEdge_MGraph(MGraph& G, char v1, char v2) {
    int i = LocateVex(G, v1);
    int j = LocateVex(G, v2);
    if (i == -1 || j == -1) return;
    G.arcs[i][j].adj = 0;
    G.arcs[j][i].adj = 0;//若是有向图可以删除这一行
    G.arcnum--;
}


//邻接矩阵→出度（有向图）
int OutDegreeMGraph(MGraph& G, int v) {
    if (v < 0 || v >= G.vexnum) {
        return -1;
    }
    int degree = 0;
    for (int j = 0; j < G.vexnum; j++) {
        if (G.arcs[v][j].adj == 1) {
            degree++;
        }
    }
    return degree;
}

//邻接矩阵→入度（有向图）
int InDegreeMGraph(MGraph& G, int v) {
    if (v < 0 || v >= G.vexnum) {
        return -1;
    }
    int degree = 0;
    for (int i = 0; i < G.vexnum; i++) {
        if (G.arcs[i][v].adj == 1) {
            degree++;
        }
    }
    return degree;
}

//邻接矩阵→邻接表
void MGraphToALGraph(MGraph& G, ALGraph& AL) {
    AL.vexnum = G.vexnum;
    AL.arcnum = G.arcnum;
    AL.kind = G.kind;

    //初始化顶点表
    for (int i = 0; i < AL.vexnum; i++) {
        AL.vertices[i].data = G.vexs[i];
        AL.vertices[i].firstarc = NULL;
    }

    //建邻接表（链表）
    for (int i = 0; i < G.vexnum; i++) {
        for (int j = 0; j < G.vexnum; j++) {
            if (G.arcs[i][j].adj == 1) {
                ArcNode* p = new ArcNode;
                p->adjvex = j;
                p->info = G.arcs[i][j].info;
                p->nextarc = AL.vertices[i].firstarc;//头插法
                AL.vertices[i].firstarc = p;
            }
        }
    }
}

//邻接矩阵→DFS遍历(深度优先搜索)
void DFS_MGraph(MGraph& G, int v, bool visited[]) {
    cout << G.vexs[v] << " ";
    visited[v] = true;
    for (int j = 0; j < G.vexnum; j++) {
        if (G.arcs[v][j].adj == 1 && !visited[j]) {
            DFS_MGraph(G, j, visited);//对尚未访问的顶点调用DFS
        }
    }
}

//邻接矩阵→BFS遍历(广度优先搜索)
void BFS_MGraph(MGraph& G, int v, bool visited[]) {
    queue<int> q;
    q.push(v);
    visited[v] = true;
    cout << G.vexs[v] << " ";
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int j = 0; j < G.vexnum; j++) {
            if (G.arcs[u][j].adj == 1 && !visited[j]) {
                visited[j] = true;
                cout << G.vexs[j] << " ";
                q.push(j);
            }
        }
    }
}

//在邻接表中根据顶点数据找下标
int LocateVex_AL(ALGraph& AL, char v) {
    for (int i = 0; i < AL.vexnum; i++) {
        if (AL.vertices[i].data == v) {//遍历顶点数组匹配数据
            return i;//找到返回下标
        }
    }
    return -1;  //未找到返回-1
}

//创建邻接表（不调用插入边函数，内部直接实现边插入）
void CreateALGraph(ALGraph& AL, GraphKind kind) {
    AL.kind = kind;
    cout << "输入邻接表的顶点数和边数：";
    cin >> AL.vexnum >> AL.arcnum;

    cout << "输入" << AL.vexnum << "个顶点（如A B C）：";
    for (int i = 0; i < AL.vexnum; i++) {
        cin >> AL.vertices[i].data; //初始化顶点数据
        AL.vertices[i].firstarc = NULL; //初始没有弧
    }

    //输入边信息并直接构建邻接表
    cout << "输入" << AL.arcnum << "条边（如A B）：" << endl;
    char v1, v2;
    int i, j;
    for (int k = 0; k < AL.arcnum; k++) {
        cin >> v1 >> v2;
        // 1. 定位两个顶点的下标
        i = LocateVex_AL(AL, v1);
        j = LocateVex_AL(AL, v2);
        if (i == -1 || j == -1) {
            cout << "顶点不存在，跳过该边！" << endl;
            continue;
        }

        //2.插入 v1→v2 的弧（头插法）
        ArcNode* p = new ArcNode;
        p->adjvex = j;
        p->info = 0; //附加信息初始化为0（可根据需求修改）
        p->nextarc = AL.vertices[i].firstarc;
        AL.vertices[i].firstarc = p;

        //3.无向图还需插入 v2→v1 的反向弧
        if (AL.kind == UDG || AL.kind == UDN) {
            ArcNode* q = new ArcNode;
            q->adjvex = i;
            q->info = 0;
            q->nextarc = AL.vertices[j].firstarc;
            AL.vertices[j].firstarc = q;
        }
    }
}

//邻接表→邻接矩阵
void ALGraphToMGraph(ALGraph& AL, MGraph& MG) {
    MG.vexnum = AL.vexnum;
    MG.arcnum = AL.arcnum;
    MG.kind = AL.kind;

    //复制顶点信息
    for (int i = 0; i < MG.vexnum; i++) {
        MG.vexs[i] = AL.vertices[i].data;
    }

    //初始化邻接矩阵
    for (int i = 0; i < MG.vexnum; i++) {
        for (int j = 0; j < MG.vexnum; j++) {
            MG.arcs[i][j].adj = INFINITY;
            MG.arcs[i][j].info = 0;
        }
    }

    //遍历邻接表填充矩阵
    for (int i = 0; i < AL.vexnum; i++) {
        ArcNode* p = AL.vertices[i].firstarc;
        while (p) {
            MG.arcs[i][p->adjvex].adj = 1;
            MG.arcs[p->adjvex][i].adj = 1;//若是有向图可以删除这一行
            p = p->nextarc;
        }
    }
}

// 邻接表→插入边
void InsertEdge_ALGraph(ALGraph& AL, char v1, char v2) {
    int i = LocateVex_AL(AL, v1);
    int j = LocateVex_AL(AL, v2);
    if (i == -1 || j == -1) return;

    ArcNode* p = new ArcNode;
    p->adjvex = j;
    p->info = 0;
    p->nextarc = AL.vertices[i].firstarc;
    AL.vertices[i].firstarc = p;

    if (AL.kind == UDG || AL.kind == UDN) {
        ArcNode* q = new ArcNode;
        q->adjvex = i;
        q->info = 0;
        q->nextarc = AL.vertices[j].firstarc;
        AL.vertices[j].firstarc = q;
    }
    AL.arcnum++;
}

//邻接表→删除边
void DeleteEdge_ALGraph(ALGraph& AL, char v1, char v2) {
    int i = LocateVex_AL(AL, v1);
    int j = LocateVex_AL(AL, v2);
    if (i == -1 || j == -1) return;

    //删除i→j的弧
    ArcNode* p = AL.vertices[i].firstarc;
    ArcNode* prev = NULL;
    while (p && p->adjvex != j) {
        prev = p;
        p = p->nextarc;
    }
    if (p) {
        if (prev) prev->nextarc = p->nextarc;
        else AL.vertices[i].firstarc = p->nextarc;
        delete p;
    }

    //无向图还要删除反向弧
    if (AL.kind == UDG || AL.kind == UDN) {
        p = AL.vertices[j].firstarc;
        prev = NULL;
        while (p && p->adjvex != i) {
            prev = p;
            p = p->nextarc;
        }
        if (p) {
            if (prev) prev->nextarc = p->nextarc;
            else AL.vertices[j].firstarc = p->nextarc;
            delete p;
        }
    }
    AL.arcnum--;
}

//邻接表→出度
int OutDegree_ALGraph(ALGraph& AL, int v) {
    if (v < 0 || v >= AL.vexnum) {
        return -1;
    }
    int degree = 0;
    ArcNode* p = AL.vertices[v].firstarc;
    while (p) {
        degree++;
        p = p->nextarc;
    }
    return degree;
}

//邻接表→入度(要遍历所有点，非常复杂，可以转化为逆邻接表)
int InDegree_ALGraph(ALGraph& AL, int v) {
    if (v < 0 || v >= AL.vexnum) return -1;
    int degree = 0;
    for (int i = 0; i < AL.vexnum; i++) {
        ArcNode* p = AL.vertices[i].firstarc;
        while (p) {
            if (p->adjvex == v) degree++;
            p = p->nextarc;
        }
    }
    return degree;
}

//邻接表→逆邻接表（有向图，存储“入边”）
void ALGraphToInverse(ALGraph& AL, ALGraph& inverseAL) {
    inverseAL.vexnum = AL.vexnum;
    inverseAL.arcnum = AL.arcnum;
    inverseAL.kind = AL.kind;

    //初始化顶点表
    for (int i = 0; i < inverseAL.vexnum; i++) {
        inverseAL.vertices[i].data = AL.vertices[i].data;
        inverseAL.vertices[i].firstarc = NULL;
    }

    //构建逆邻接表
    for (int i = 0; i < AL.vexnum; i++) {
        ArcNode* p = AL.vertices[i].firstarc;
        while (p) {
            ArcNode* q = new ArcNode;
            q->adjvex = i;
            q->info = p->info;
            q->nextarc = inverseAL.vertices[p->adjvex].firstarc;//头插法
            inverseAL.vertices[p->adjvex].firstarc = q;
            p = p->nextarc;
        }
    }
}

//根据逆邻接表计算入度（逆邻接表中v的邻接表长度即为入度）
//仅适用于有向图，无向图的逆邻接表与原表一致
int InDegree_InvALGraph(ALGraph& invAL, int v) {
    if (v < 0 || v >= invAL.vexnum) {//检查顶点索引合法性
        return -1;
    }
    int inDegree = 0;
    ArcNode* p = invAL.vertices[v].firstarc;//指向逆邻接表中v的第一个邻接节点
    while (p != NULL) {//遍历邻接表，统计节点数量
        inDegree++;
        p = p->nextarc;
    }
    return inDegree;
}

//邻接表→DFS遍历(深度优先搜索)
void DFS_ALGraph(ALGraph& AL, int v, bool visited[]) {
    cout << AL.vertices[v].data << " ";
    visited[v] = true;
    ArcNode* p = AL.vertices[v].firstarc;
    while (p) {
        if (!visited[p->adjvex]) {
            DFS_ALGraph(AL, p->adjvex, visited);
        }
        p = p->nextarc;
    }
}

//邻接表→BFS遍历(广度优先搜索)
void BFS_ALGraph(ALGraph& AL, int v, bool visited[]) {
    queue<int> q;
    q.push(v);
    visited[v] = true;
    cout << AL.vertices[v].data << " ";
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        ArcNode* p = AL.vertices[u].firstarc;
        while (p) {
            if (!visited[p->adjvex]) {
                visited[p->adjvex] = true;
                cout << AL.vertices[p->adjvex].data << " ";
                q.push(p->adjvex);
            }
            p = p->nextarc;
        }
    }
}

//邻接表销毁函数：释放所有动态分配的ArcNode节点，避免内存泄漏
void DestroyALGraph(ALGraph& AL) {
    //遍历每个顶点的邻接表
    for (int i = 0; i < AL.vexnum; i++) {
        ArcNode* current = AL.vertices[i].firstarc;//指向当前顶点的第一条弧
        while (current != NULL) {
            ArcNode* temp = current;//保存当前节点指针
            current = current->nextarc;//移动到下一条弧
            delete temp;//释放当前节点（用new分配的必须用delete释放）
            temp = NULL;//避免野指针
        }
        AL.vertices[i].firstarc = NULL; //清空顶点的弧指针
    }
}

int main() {
    //略
    return 0;
}
```

### 二、代码模块拆分解释

#### 1. 宏定义与图类型枚举

##### （1）宏定义

```cpp
#define MAX_VERTEX_NUM 20   // 最大顶点数
#define INFINITY 65535     // 无穷大（用于有权图权值或无权图的“无连接”标记）
```

- 功能：定义图的顶点数量上限和 “无连接” 标记。
  - `MAX_VERTEX_NUM`：限制图的最大顶点数为 20，避免动态内存分配，简化实现。
  - `INFINITY`：用 65535 表示 “无连接”（有权图中表示无穷大权重，无权图中表示两点不相邻）。

##### （2）图的类型枚举（`GraphKind`）

```cpp
typedef enum { DG, DN, UDG, UDN } GraphKind;
```

- 功能：区分图的类型，共 4 种：
  - `DG`：有向图（边无权重，仅表示方向）；
  - `DN`：有向网（边带权重）；
  - `UDG`：无向图（边无权重，双向可达）；
  - `UDN`：无向网（边带权重，双向可达）。
- **代码中用法**：后续结构（如`MGraph`、`ALGraph`）通过该枚举标记图类型，辅助判断边的处理逻辑（如无向图需双向边）。

#### 2. 邻接矩阵相关结构定义

##### （1）邻接矩阵的 “边单元”（`ArcCell`）与邻接矩阵类型（`AdjMatrix`）

```cpp
typedef struct ArcCell{
    int adj;         // 无权图用0/1表示是否连接，有权图存储权值
    int * info;      // 弧/边的附加信息的指针（int类型可改）
}ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];
```

- `ArcCell` 结构：存储单条边的信息：
  - `adj`：核心字段，无权图中`1`表示 “有边”，`0`或`INFINITY`表示 “无边”；有权图中直接存储权重。
  - `info`：附加信息指针（如边的描述），当前代码初始化为`0`，可扩展。
- **`AdjMatrix` 类型**：本质是二维数组（`MAX_VERTEX_NUM x MAX_VERTEX_NUM`），用于存储整个图的边关系（邻接矩阵的核心容器）。

##### （2）邻接矩阵表示的图（`MGraph`）

```cpp
typedef struct MGraph {
    char vexs[MAX_VERTEX_NUM];  // 顶点向量（存储顶点数据，如'A'、'B'）
    AdjMatrix arcs;             // 邻接矩阵（存储边关系）
    int vexnum;                 // 当前顶点数
    int arcnum;                 // 当前弧/边数
    GraphKind kind;             // 图的类型标志
}MGraph;
```

- 结构说明：完整描述邻接矩阵图：
  - `vexs`：数组存储顶点的具体数据（如字符型顶点名）；
  - `arcs`：二维数组存储边的连接关系（通过`ArcCell`结构）；
  - `vexnum`和`arcnum`：记录当前顶点数和边数，用于边界判断；
  - `kind`：标记图类型（关联`GraphKind`）。

#### 3. 邻接表相关结构定义

##### （1）邻接表的 “弧结点”（`ArcNode`）

```cpp
typedef struct ArcNode {
    int adjvex;                 // 邻接顶点的位置下标（指向哪个顶点）
    struct ArcNode * nextarc;   // 指向下一条弧的指针（形成链表）
    int * info;                 // 弧的附加信息
} ArcNode;
```

- 功能：存储单条边（弧）的信息，是邻接表的 “边单元”：
  - `adjvex`：记录这条边指向的顶点下标（如从顶点`i`出发，指向`j`，则`adjvex = j`）；
  - `nextarc`：指针串联同一顶点出发的所有边（形成 “邻接链”）；
  - `info`：附加信息，与`ArcCell`的`info`作用一致。

##### （2）邻接表的 “顶点结点”（`VNode`）与邻接表类型（`AdjList`）

```cpp
typedef struct VNode {
    char data;                  // 顶点信息（如'A'、'B'）
    ArcNode * firstarc;         // 指向第一条依附该顶点的弧的指针
} VNode, AdjList[MAX_VERTEX_NUM];
```

- `VNode` 结构：描述邻接表中的一个顶点：
  - `data`：顶点的具体数据（与邻接矩阵的`vexs`对应）；
  - `firstarc`：指针指向从该顶点出发的第一条边（邻接链的起点）。
- **`AdjList` 类型**：`VNode`数组（大小`MAX_VERTEX_NUM`），存储所有顶点，构成邻接表的基础。

##### （3）邻接表表示的图（`ALGraph`）

```cpp
typedef struct ALGraph{
    AdjList vertices;           // 邻接表数组（存储所有顶点及邻接链）
    int vexnum;                 // 当前顶点数
    int arcnum;                 // 当前弧/边数
    GraphKind kind;             // 图的类型标志
} ALGraph;
```

- 结构说明：完整描述邻接表图：
  - `vertices`：核心字段，`VNode`数组，每个元素对应一个顶点及从其出发的边链；
  - `vexnum`和`arcnum`：记录顶点数和边数；
  - `kind`：标记图类型，用于判断边的处理逻辑（如无向图需双向弧）。

#### 4. 顶点定位函数

##### （1）邻接矩阵中定位顶点下标（`LocateVex`）

```cpp
int LocateVex(MGraph& G, char v) {
    for (int i = 0; i < G.vexnum; i++) {
        if (G.vexs[i] == v) return i;
    }
    return -1; // 顶点不存在
}
```

- **功能**：根据顶点数据（如`'A'`）查找其在邻接矩阵`vexs`数组中的下标（如`0`、`1`）。
- **逻辑**：遍历`G.vexs`数组，匹配目标顶点`v`，返回下标；未找到返回`-1`。
- **用途**：为插入边、删除边等操作提供顶点索引（邻接矩阵通过下标访问）。

##### （2）邻接表中定位顶点下标（`LocateVex_AL`）

```cpp
int LocateVex_AL(ALGraph& AL, char v) {
    for (int i = 0; i < AL.vexnum; i++) {
        if (AL.vertices[i].data == v) { // 匹配顶点数据
            return i; // 返回下标
        }
    }
    return -1;  // 未找到返回-1
}
```

- **功能**：根据顶点数据查找其在邻接表`vertices`数组中的下标。
- **逻辑**：遍历`AL.vertices`数组，比较每个顶点的`data`字段，匹配则返回下标；否则返回`-1`。
- **与`LocateVex`的区别**：操作对象不同（邻接表的`VNode`数组 vs 邻接矩阵的`char`数组），但定位逻辑一致（遍历匹配）。

#### 5. 邻接矩阵的创建与边操作

##### （1）创建邻接矩阵图（`CreateMGraph`）

```cpp
void CreateMGraph(MGraph& G, GraphKind kind) {
    cout << "输入顶点数和弧/边数：";
    cin >> G.vexnum >> G.arcnum;

    cout << "输入" << G.vexnum << "个顶点：" << endl;
    for (int i = 0; i < G.vexnum; i++) {
        cin >> G.vexs[i];
    }

    // 初始化邻接矩阵
    for (int i = 0; i < G.vexnum; i++) {
        for (int j = 0; j < G.vexnum; j++) {
            G.arcs[i][j].adj = INFINITY;
            G.arcs[i][j].info = 0;
        }
    }

    // 输入弧/边信息
    cout << "输入每条弧/边的两个顶点（如A B）：" << endl;
    char v1, v2;
    int i, j;
    for (int k = 0; k < G.arcnum; k++) {
        cin >> v1 >> v2;
        i = LocateVex(G, v1);
        j = LocateVex(G, v2);
        G.arcs[i][j].adj = 1; // "1"也可以是权值
        G.arcs[j][i].adj = 1; // 若是有向图可以删除这一行
    }
}
```

- **功能**：从用户输入初始化邻接矩阵图。
- 步骤解析：
  1. 输入顶点数`vexnum`和边数`arcnum`；
  2. 输入顶点数据到`vexs`数组；
  3. 初始化邻接矩阵：所有边默认设为`INFINITY`（无连接），附加信息为`0`；
  4. 逐条输入边的两个顶点，定位下标后标记连接（`adj = 1`）；
  5. 对无向图，手动添加反向边（`G.arcs[j][i].adj = 1`），有向图需删除此行。

##### （2）邻接矩阵插入边（`InsertEdge_MGraph`）

```cpp
void InsertEdge_MGraph(MGraph& G, char v1, char v2) {
    int i = LocateVex(G, v1);
    int j = LocateVex(G, v2);
    if (i == -1 || j == -1) {
        return;
    }
    G.arcs[i][j].adj = 1;
    G.arcs[j][i].adj = 1; // 若是有向图可以删除这一行
    G.arcnum++;
}
```

- **功能**：向邻接矩阵添加一条边（`v1→v2`）。
- 逻辑：
  1. 定位`v1`和`v2`的下标`i`、`j`，顶点不存在则直接返回；
  2. 标记`arcs[i][j].adj = 1`（有边）；
  3. 无向图需同步标记`arcs[j][i].adj = 1`，有向图删除此行；
  4. 边数`arcnum`加 1。

##### （3）邻接矩阵删除边（`DeleteEdge_MGraph`）

```cpp
void DeleteEdge_MGraph(MGraph& G, char v1, char v2) {
    int i = LocateVex(G, v1);
    int j = LocateVex(G, v2);
    if (i == -1 || j == -1) return;
    G.arcs[i][j].adj = 0;
    G.arcs[j][i].adj = 0; // 若是有向图可以删除这一行
    G.arcnum--;
}
```

- **功能**：从邻接矩阵删除一条边（`v1→v2`）。
- 逻辑：
  1. 定位顶点下标，不存在则返回；
  2. 标记`arcs[i][j].adj = 0`（无边）；
  3. 无向图同步标记`arcs[j][i].adj = 0`，有向图删除此行；
  4. 边数`arcnum`减 1。

#### 6. 邻接矩阵的度计算

##### （1）邻接矩阵计算出度（`OutDegreeMGraph`）

```cpp
int OutDegreeMGraph(MGraph& G, int v) {
    if (v < 0 || v >= G.vexnum) {
        return -1;
    }
    int degree = 0;
    for (int j = 0; j < G.vexnum; j++) {
        if (G.arcs[v][j].adj == 1) {
            degree++;
        }
    }
    return degree;
}
```

- **功能**：计算有向图中顶点`v`的出度（从`v`出发的边数）。
- 逻辑：
  1. 检查顶点`v`的索引合法性（`0 <= v < vexnum`）；
  2. 遍历`v`对应的行（`arcs[v][j]`），统计`adj == 1`的数量（存在的边）。

##### （2）邻接矩阵计算入度（`InDegreeMGraph`）

```cpp
int InDegreeMGraph(MGraph& G, int v) {
    if (v < 0 || v >= G.vexnum) {
        return -1;
    }
    int degree = 0;
    for (int i = 0; i < G.vexnum; i++) {
        if (G.arcs[i][v].adj == 1) {
            degree++;
        }
    }
    return degree;
}
```

- **功能**：计算有向图中顶点`v`的入度（指向`v`的边数）。
- 逻辑：
  1. 检查顶点索引合法性；
  2. 遍历`v`对应的列（`arcs[i][v]`），统计`adj == 1`的数量。

#### 7. 邻接矩阵与邻接表的转换

##### （1）邻接矩阵转邻接表（`MGraphToALGraph`）

```cpp
void MGraphToALGraph(MGraph& G, ALGraph& AL) {
    AL.vexnum = G.vexnum;
    AL.arcnum = G.arcnum;
    AL.kind = G.kind;

    // 初始化顶点表
    for (int i = 0; i < AL.vexnum; i++) {
        AL.vertices[i].data = G.vexs[i];
        AL.vertices[i].firstarc = NULL;
    }

    // 建邻接表（链表）
    for (int i = 0; i < G.vexnum; i++) {
        for (int j = 0; j < G.vexnum; j++) {
            if (G.arcs[i][j].adj == 1) {
                ArcNode* p = new ArcNode;
                p->adjvex = j;
                p->info = G.arcs[i][j].info;
                p->nextarc = AL.vertices[i].firstarc; // 头插法
                AL.vertices[i].firstarc = p;
            }
        }
    }
}
```

- **功能**：将邻接矩阵图转换为邻接表图。
- 步骤解析：
  1. 复制顶点数、边数、图类型等元信息；
  2. 复制顶点数据到邻接表的`vertices`数组，初始化邻接链为空；
  3. 遍历邻接矩阵，对每个`arcs[i][j].adj == 1`（存在边`i→j`）：
     - 创建`ArcNode`节点，记录邻接顶点`j`和附加信息；
     - 用头插法插入到顶点`i`的邻接链（新节点指向原首节点，更新首节点）。

#### 8. 邻接矩阵的遍历

##### （1）邻接矩阵的 DFS 遍历（`DFS_MGraph`）

```cpp
void DFS_MGraph(MGraph& G, int v, bool visited[]) {
    cout << G.vexs[v] << " ";
    visited[v] = true;
    for (int j = 0; j < G.vexnum; j++) {
        if (G.arcs[v][j].adj == 1 && !visited[j]) {
            DFS_MGraph(G, j, visited); // 对尚未访问的顶点调用DFS
        }
    }
}
```

- **功能**：从顶点`v`出发，深度优先搜索（DFS）邻接矩阵图。
- 核心逻辑：
  1. 访问顶点`v`（输出数据），标记`visited[v] = true`（避免重复访问）；
  2. 遍历所有顶点`j`，若存在边`v→j`且`j`未访问，递归访问`j`。

##### （2）邻接矩阵的 BFS 遍历（`BFS_MGraph`）

```cpp
void BFS_MGraph(MGraph& G, int v, bool visited[]) {
    queue<int> q;
    q.push(v);
    visited[v] = true;
    cout << G.vexs[v] << " ";
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int j = 0; j < G.vexnum; j++) {
            if (G.arcs[u][j].adj == 1 && !visited[j]) {
                visited[j] = true;
                cout << G.vexs[j] << " ";
                q.push(j);
            }
        }
    }
}
```

- **功能**：从顶点`v`出发，广度优先搜索（BFS）邻接矩阵图。
- 核心逻辑：
  1. 初始化队列，将`v`入队并标记访问，输出`v`的数据；
  2. 循环出队顶点u，遍历其所有邻接顶点j：
     - 若`j`未访问，标记访问、输出数据并入队；
  3. 直到队列为空，完成遍历。

#### 9. 邻接表的创建与转换

##### （1）创建邻接表（`CreateALGraph`）

```cpp
void CreateALGraph(ALGraph& AL, GraphKind kind) {
    AL.kind = kind;
    cout << "输入邻接表的顶点数和边数：";
    cin >> AL.vexnum >> AL.arcnum;

    cout << "输入" << AL.vexnum << "个顶点（如A B C）：";
    for (int i = 0; i < AL.vexnum; i++) {
        cin >> AL.vertices[i].data; // 初始化顶点数据
        AL.vertices[i].firstarc = NULL; // 初始没有弧
    }

    // 输入边信息并直接构建邻接表
    cout << "输入" << AL.arcnum << "条边（如A B）：" << endl;
    char v1, v2;
    int i, j;
    for (int k = 0; k < AL.arcnum; k++) {
        cin >> v1 >> v2;
        // 1. 定位两个顶点的下标
        i = LocateVex_AL(AL, v1);
        j = LocateVex_AL(AL, v2);
        if (i == -1 || j == -1) {
            cout << "顶点不存在，跳过该边！" << endl;
            continue;
        }

        // 2. 插入 v1→v2 的弧（头插法）
        ArcNode* p = new ArcNode;
        p->adjvex = j;
        p->info = 0; // 附加信息初始化为0（可根据需求修改）
        p->nextarc = AL.vertices[i].firstarc;
        AL.vertices[i].firstarc = p;

        // 3. 无向图还需插入 v2→v1 的反向弧
        if (AL.kind == UDG || AL.kind == UDN) {
            ArcNode* q = new ArcNode;
            q->adjvex = i;
            q->info = 0;
            q->nextarc = AL.vertices[j].firstarc;
            AL.vertices[j].firstarc = q;
        }
    }
}
```

- **功能**：从用户输入初始化邻接表图。
- 步骤解析：
  1. 输入顶点数、边数，设置图类型；
  2. 输入顶点数据到`vertices`数组，初始化邻接链为空；
  3. 逐条输入边的两个顶点，定位下标后：
     - 用头插法插入`v1→v2`的弧（`ArcNode`节点）；
     - 若为无向图（`UDG`或`UDN`），自动插入`v2→v1`的反向弧。

##### （2）邻接表转邻接矩阵（`ALGraphToMGraph`）

```cpp
void ALGraphToMGraph(ALGraph& AL, MGraph& MG) {
    MG.vexnum = AL.vexnum;
    MG.arcnum = AL.arcnum;
    MG.kind = AL.kind;

    // 复制顶点信息
    for (int i = 0; i < MG.vexnum; i++) {
        MG.vexs[i] = AL.vertices[i].data;
    }

    // 初始化邻接矩阵
    for (int i = 0; i < MG.vexnum; i++) {
        for (int j = 0; j < MG.vexnum; j++) {
            MG.arcs[i][j].adj = INFINITY;
            MG.arcs[i][j].info = 0;
        }
    }

    // 遍历邻接表填充矩阵
    for (int i = 0; i < AL.vexnum; i++) {
        ArcNode* p = AL.vertices[i].firstarc;
        while (p) {
            MG.arcs[i][p->adjvex].adj = 1;
            MG.arcs[p->adjvex][i].adj = 1; // 若是有向图可以删除这一行
            p = p->nextarc;
        }
    }
}
```

- **功能**：将邻接表图转换为邻接矩阵图。
- 步骤解析：
  1. 复制元信息（顶点数、边数、图类型）；
  2. 复制顶点数据到邻接矩阵的`vexs`数组；
  3. 初始化邻接矩阵为`INFINITY`（无连接）；
  4. 遍历邻接表的每个顶点i的邻接链：
     - 对每条弧`i→j`（`p->adjvex = j`），标记矩阵`arcs[i][j].adj = 1`；
     - 无向图同步标记`arcs[j][i].adj = 1`，有向图删除此行。

#### 10. 邻接表的边操作

##### （1）邻接表插入边（`InsertEdge_ALGraph`）

```cpp
void InsertEdge_ALGraph(ALGraph& AL, char v1, char v2) {
    int i = LocateVex_AL(AL, v1);
    int j = LocateVex_AL(AL, v2);
    if (i == -1 || j == -1) return;

    ArcNode* p = new ArcNode;
    p->adjvex = j;
    p->info = 0;
    p->nextarc = AL.vertices[i].firstarc;
    AL.vertices[i].firstarc = p;

    if (AL.kind == UDG || AL.kind == UDN) {
        ArcNode* q = new ArcNode;
        q->adjvex = i;
        q->info = 0;
        q->nextarc = AL.vertices[j].firstarc;
        AL.vertices[j].firstarc = q;
    }
    AL.arcnum++;
}
```

- **功能**：向邻接表添加一条边（`v1→v2`）。
- 逻辑：
  1. 定位顶点下标，不存在则返回；
  2. 用头插法插入`i→j`的弧（新节点指向原首节点，更新首节点）；
  3. 无向图（`UDG`或`UDN`）同步插入`j→i`的反向弧；
  4. 边数`arcnum`加 1。

##### （2）邻接表删除边（`DeleteEdge_ALGraph`）

```cpp
void DeleteEdge_ALGraph(ALGraph& AL, char v1, char v2) {
    int i = LocateVex_AL(AL, v1);
    int j = LocateVex_AL(AL, v2);
    if (i == -1 || j == -1) return;

    // 删除i→j的弧
    ArcNode* p = AL.vertices[i].firstarc;
    ArcNode* prev = NULL;
    while (p && p->adjvex != j) {
        prev = p;
        p = p->nextarc;
    }
    if (p) {
        if (prev) prev->nextarc = p->nextarc;
        else AL.vertices[i].firstarc = p->nextarc;
        delete p;
    }

    // 无向图还要删除反向弧
    if (AL.kind == UDG || AL.kind == UDN) {
        p = AL.vertices[j].firstarc;
        prev = NULL;
        while (p && p->adjvex != i) {
            prev = p;
            p = p->nextarc;
        }
        if (p) {
            if (prev) prev->nextarc = p->nextarc;
            else AL.vertices[j].firstarc = p->nextarc;
            delete p;
        }
    }
    AL.arcnum--;
}
```

- **功能**：从邻接表删除一条边（`v1→v2`）。
- 逻辑：
  1. 定位顶点下标，不存在则返回；
  2. 遍历i的邻接链，查找指向`j`的弧（`p->adjvex == j`）：
     - 若为中间节点（`prev != NULL`）：`prev->nextarc = p->nextarc`（跳过`p`）；
     - 若为头节点（`prev == NULL`）：`vertices[i].firstarc = p->nextarc`（更新首指针）；
     - 释放`p`节点内存；
  3. 无向图同步删除反向弧`j→i`，逻辑同上；
  4. 边数`arcnum`减 1。

#### 11. 邻接表的度计算

##### （1）邻接表计算出度（`OutDegree_ALGraph`）

```cpp
int OutDegree_ALGraph(ALGraph& AL, int v) {
    if (v < 0 || v >= AL.vexnum) {
        return -1;
    }
    int degree = 0;
    ArcNode* p = AL.vertices[v].firstarc;
    while (p) {
        degree++;
        p = p->nextarc;
    }
    return degree;
}
```

- **功能**：计算顶点`v`的出度（从`v`出发的边数）。
- 逻辑：
  1. 检查顶点索引合法性；
  2. 遍历`v`的邻接链（`firstarc`开始），统计弧的数量（每个弧对应一条出边）。

##### （2）邻接表计算入度（低效方法，`InDegree_ALGraph`）

```cpp
int InDegree_ALGraph(ALGraph& AL, int v) {
    if (v < 0 || v >= AL.vexnum) return -1;
    int degree = 0;
    for (int i = 0; i < AL.vexnum; i++) {
        ArcNode* p = AL.vertices[i].firstarc;
        while (p) {
            if (p->adjvex == v) degree++;
            p = p->nextarc;
        }
    }
    return degree;
}
```

- **功能**：计算顶点`v`的入度（指向`v`的边数）。
- 逻辑：
  1. 遍历所有顶点`i`的邻接链；
  2. 对每条弧`i→j`，若`j == v`（指向`v`），则入度加 1。
- **缺点**：需遍历整个邻接表，时间复杂度高（`O(n + e)`，`n`为顶点数，`e`为边数）。

##### （3）邻接表转逆邻接表（`ALGraphToInverse`）

```cpp
void ALGraphToInverse(ALGraph& AL, ALGraph& inverseAL) {
    inverseAL.vexnum = AL.vexnum;
    inverseAL.arcnum = AL.arcnum;
    inverseAL.kind = AL.kind;

    // 初始化顶点表
    for (int i = 0; i < inverseAL.vexnum; i++) {
        inverseAL.vertices[i].data = AL.vertices[i].data;
        inverseAL.vertices[i].firstarc = NULL;
    }

    // 构建逆邻接表
    for (int i = 0; i < AL.vexnum; i++) {
        ArcNode* p = AL.vertices[i].firstarc;
        while (p) {
            ArcNode* q = new ArcNode;
            q->adjvex = i;
            q->info = p->info;
            q->nextarc = inverseAL.vertices[p->adjvex].firstarc; // 头插法
            inverseAL.vertices[p->adjvex].firstarc = q;
            p = p->nextarc;
        }
    }
}
```

- **功能**：为有向图生成逆邻接表（存储 “入边” 信息）。
- 核心逻辑：
  - 逆邻接表顶点与原表一致；
  - 原表中每条弧`i→j`（从`i`到`j`），在逆表中转为弧`j→i`（从`j`到`i`），即 “原边的终点变起点，起点变终点”。

##### （4）逆邻接表计算入度（高效方法，`InDegree_InvALGraph`）

```cpp
int InDegree_InvALGraph(ALGraph& invAL, int v) {
    if (v < 0 || v >= invAL.vexnum) { // 检查顶点索引合法性
        return -1;
    }
    int inDegree = 0;
    ArcNode* p = invAL.vertices[v].firstarc; // 指向逆邻接表中v的第一个邻接节点
    while (p != NULL) { // 遍历邻接表，统计节点数量
        inDegree++;
        p = p->nextarc;
    }
    return inDegree;
}
```

- **功能**：利用逆邻接表高效计算顶点`v`的入度。
- 逻辑：
  - 逆邻接表中，顶点`v`的邻接链长度 = 指向`v`的边数（入度）；
  - 遍历`v`的邻接链，统计弧的数量即可。

#### 12. 邻接表的遍历

##### （1）邻接表的 DFS 遍历（`DFS_ALGraph`）

```cpp
void DFS_ALGraph(ALGraph& AL, int v, bool visited[]) {
    cout << AL.vertices[v].data << " ";
    visited[v] = true;
    ArcNode* p = AL.vertices[v].firstarc;
    while (p) {
        if (!visited[p->adjvex]) {
            DFS_ALGraph(AL, p->adjvex, visited);
        }
        p = p->nextarc;
    }
}
```

- **功能**：从顶点`v`出发，DFS 遍历邻接表图。
- 逻辑：
  1. 访问顶点`v`，标记`visited[v] = true`；
  2. 遍历`v`的邻接链（`p = p->nextarc`），对未访问的邻接顶点递归调用`DFS_ALGraph`。

##### （2）邻接表的 BFS 遍历（`BFS_ALGraph`）

```cpp
void BFS_ALGraph(ALGraph& AL, int v, bool visited[]) {
    queue<int> q;
    q.push(v);
    visited[v] = true;
    cout << AL.vertices[v].data << " ";
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        ArcNode* p = AL.vertices[u].firstarc;
        while (p) {
            if (!visited[p->adjvex]) {
                visited[p->adjvex] = true;
                cout << AL.vertices[p->adjvex].data << " ";
                q.push(p->adjvex);
            }
            p = p->nextarc;
        }
    }
}
```

- **功能**：从顶点`v`出发，BFS 遍历邻接表图。
- 逻辑：
  1. 初始化队列，将`v`入队并标记访问，输出`v`的数据；
  2. 循环出队顶点u，遍历其邻接链：
     - 对未访问的邻接顶点`p->adjvex`，标记访问、输出数据并入队；
  3. 直到队列为空，完成遍历。

#### 13.邻接表的销毁（`DestroyALGraph`）

```cpp
void DestroyALGraph(ALGraph& AL) {
    // 遍历每个顶点的邻接表
    for (int i = 0; i < AL.vexnum; i++) {
        ArcNode* current = AL.vertices[i].firstarc; // 指向当前顶点的第一条弧
        while (current != NULL) {
            ArcNode* temp = current; // 保存当前节点指针
            current = current->nextarc; // 移动到下一条弧
            delete temp; // 释放当前节点（用new分配的必须用delete释放）
            temp = NULL; // 避免野指针
        }
        AL.vertices[i].firstarc = NULL; // 清空顶点的弧指针
    }
}
```

- **功能**：释放邻接表中所有动态分配的`ArcNode`节点，避免内存泄漏。
- 逻辑：
  - 遍历每个顶点`i`的邻接链；
  - 用`current`指针遍历链，`temp`保存当前节点，释放后移动到下一个节点；
  - 最后清空顶点的`firstarc`指针。